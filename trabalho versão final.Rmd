---
title: "Melquisadec"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE,warning = FALSE)
```

# Serie hist√≥rica da exporta√ß√£o brasileira em kg
## Resumo 




# Introdu√ß√£o.
A proposta de explora√ß√£o no mercado brasileiro se iniciou desde a √©poca em que era col√¥nia de Portugal, nesta √©poca inicia se a explora√ß√£o do ouro e comecializa√ß√£o no mercado internacional, posteriormente a exporta√ß√£o do Pau Brasil, a√ßucar e caf√© (Contine et al 2012). O Brasil se tornou um dos maiores exportadores de diversas materia prima nas √∫ltimas duas d√©cadas, no cen√°rio internacional, principalmente as commodities agr√≠colas que de certa forma elevou o percentual de exporta√ß√£o brasileira (Souza e ver√≠ssimo 2013), o Brasil se destaca em algumas culturas como soja, milho e caf√©, de modo geral o pa√≠s est√° entre os maiores exportadores mundiais no que tange a culturas de produ√ß√£o de gr√£os(CONAB 2022), partir deste crescimento faz se necess√°rios modelos de previs√µes que viabiliza o conhecimento pr√©vio do comportamento do mercado internacional, tais modelos facilitam na tomada de decis√µes dos setores estrat√©gicos do pa√≠s. Dentre os modelos de previs√µes destaca-se as series temporais. Series temporais s√£o sequ√™ncias de observa√ß√µes de uma vari√°vel ao longo do tempo e a partir destas observa√ßoes √© poss√≠vel estender um horizonte de previs√£o para a vari√°vel de interesse.  
Neste trabalho considerou-se uma serie hist√≥rica de exporta√ß√£o Brasileira, e a partir de ent√£o descrever com modelo de series temporais um horizonte de previs√£o para as pr√≥ximas exporta√ß√µes do Pa√≠s atrav√©s do modelo Arima sazonal.o chamado modelo ARIMA sazonal, ou SARIMA (MORETTIN & TOLOI, 2004). Estes modelos s√£o importantes, pois levam em considera√ß√£o a sazonalidade estoc√°stica dos dados. Quando o per√≠odo s=12, o modelo denominado SARIMA de ordem (p,d,q) √ó (P,D,Q)12, √© dado por: œÜ(X)Œ¶(X12)‚àÜ d‚àÜD12 Zt = Œ∏(X)Œò(X)at

```{r}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
if (!require("pacman")) install.packages("pacman")
p_load(tidyverse, rmdformats,forecast,ggthemes,tseries,magrittr,astsa, rmarkdown,RColorBrewer,extRemes,data.table,quantmod,Quandl, sf,tidyr,tinytex, ggplot2,readxl,xlsx,openxlsx,stringr,vroom,egg,writexl,knitr,cowplot,forecTheta,
      Mcomp, kableExtra)

```

```{r, warning=FALSE}
treino2=read.table("dados.txt", header = T)
validacao=read.table("dadosva.txt", header = T)
xtreino=treino2[1:228,]
xteste=validacao[1:60,]

x<- ts(xtreino, start=1999, frequency = 12) #transformando numa serie temporal

xx=ts(xteste, start = 2018, frequency = 12)

h=length(xx)
```
## Materias e M√©todos
### Dados
A serie hist√≥rica da exporta√ß√£o foi obtido no site da Receita Federal Brasileira, o conjunto de dados s√£o referente a observa√ß√µes de quilos exportados a partir do ano de 1999 at√© 2022, por√©m o conjunto foi particionado para conjunto de treinamento e conjunto de valida√ß√£o, para o treinamento foi considerado as observa√ßoes de 1999 at√© o ano de 2018 e para valida√ß√£o foi considerado do ano 2018 a 2022. Os modelos proposto para esta an√°lise foram arima sazonal com os dados originais, arima sozonal tomado por uma transforma√ß√£o de boxcox nos dados
A defini√ß√£o matem√°tica do modelo ARIMA sazonal segundo BOX e JENKINS (1974) √© representada da seguinte forma:
ùúô(ùêµ)Œ¶(ùêµùë†)ùëäùë° = ùúÉ(ùêµ)Œò(ùêµùë†)ùëéùë°com: 
ùëäùë° = ‚àáùë†ùëë‚àáùëëùëãùë°e com os seguintes operadores:
- auto-regressivo n√£o sazonal -\phi ùúô(ùêµ) = (1 ‚àí ùõº1ùêµ ‚àí ‚ãØ ‚àí ùõºùëùùêµùëù);
- auto-regressivo sazonal - Œ¶(ùêµùë†) = (1 ‚àí ùúôùë†ùêµùë† ‚àí ‚ãØ ‚àí ùúôùëùùêµùëÉùë†);
‚Äì m√©dia m√≥vel n√£o sazonal.- Œ∏(B) = (1 + ùõΩ1ùêµ + ‚ãØ + ùõΩùëûùêµùëû;Œò(ùêµùë†) = (1 + ùúÉùë†ùêµùë† ‚àí ‚ãØ ‚àí ùúÉùëùùêµùëÑùë†) 
‚Äì operador m√©dia m√≥vel sazonal;‚àáùëë
‚Äì operador diferen√ßa n√£o sazonal de ordem d;‚àáùë†ùëë
‚Äì operador diferen√ßa sazonal de ordem D.

Foram utilizados os modelos de alisamento exponencial (ETS) e OS modelos ETS com a serie tomada por uma transforma√ß√£o de boxcox.
Os modelos ETS em s√©rie temporal s√£o modelos que avaliam erro, tend√™ncia e sazonalidade. O erro pode ser multiplicativo (M) ou aditivo (A), a tend√™ncia pode n√£o ter (N), ser multiplicativa (M), multiplicativa amortecida (Md), aditiva (A) ou aditiva amortecida (Ad) e a sazonalidade pode n√£o ocorrer (N), ser multiplicativa (M) ou aditiva (A). Equa√ß√µes do modelo ETS com erros aditivos e multiplicativos podem ser encontrados em Hyndman et al. (2008).

Para o crit√©rio de escolha do melhor modelo foram utilizados a t√©cnica de janela deslizante, o modelo que obter o menor erro absoluto √© o escolhido para fazer previs√µes O software utilizado para tratamento dos dados foi o software Livre R TEAM 2022.  

## Resultados 
Foi realizado a decomposi√ß√£o da serie hist√≥rica para verificar o comportamento dos dados, utilizando a fun√ß√£o mstl do R, esta fun√ß√£o divide os termos de tend√™ncia, sazonalidade e Ruido da serie, pode-se identificar na figura 1 os termos de tend√™ncia, ou seja, houve um aumento no na exporta√ß√£o Brasileira comparando os anos de 1999 a 2018, percebe-se tamb√©m um padr√£o sazonal, justific√°vel pois grandes volumes de exporta√ß√µes s√£o referntes ao setor agrario e este setor possui √©pocas determinadas para colheitas, o que geram ciclos sazonais, e por fim o termo de Ruido da s√©rie que aparenta um ruido aleat√≥rio.

```{r}
mstl(x, lambda = NULL) %>% autoplot(facet=TRUE, size=0.7, color ="red") + theme_minimal()
```

Para aplica√ß√£o dos modelos classes arimas √© necessario que a serie seja estacionaria (Moretin 2004)  Se uma s√©rie {Zt} √© n√£o estacion√°ria, logo faz se uma diferen√ßa do tipo Wt = Zt - Zt-1 , este processo √© feito recursivamente at√© que a serie se torne estacion√°ria, como visto na decomposi√ß√£o na figura 1 os dados apresentam tend√™ncia de crescimento e para fazer com que a serie seja estacion√°ria foram necess√°rios aplicar uma diferencia√ß√£o, esta fun√ß√£o de difern√ßa ja esta implementada no software R basta acionar a fun√ß√£o ndifss() para checar se necessita de diferen√ßa simples e caso necessite aplica a diferen√ßa e nsdiffs() para checar a sazonalidade esta fun√ß√£o retorna a quantidade de difen√ßas para que a serie se torne estacion√°ria. Ap√≥s este procedimento verificou que apenas uma diferen√ßa simples e a serie se tornou estacion√°ria.Na figura 2 tem-se as fun√ß√µes de autocorrela√ß√£o(ACF) e autocorrela√ß√£o parcial (PACF), estas fun√ß√µes s√£o as representa√ß√µes gr√°ficas dos coeficientes de autocorrela√ß√£o em fun√ß√£o dos retardos (BOX, JENKINS E REINSEL, 1994), na medida em que este gr√°fico demostram os lags escapam das bandas limites significa que ainda h√° autocorrela√ß√£o e o processo n√£o se tornou estacion√°rios, e por estes gr√°ficos em alguns casos pode-se deduzir a ordem do modelo, neste trabalho foi possivel deduzir apenas a ordem d=1 e D=0, n√£o sendo poss√≠vel obter um modelo completo de forma visual.


```{r}
x %>% ndiffs()
dados.diff<- diff(x)
dados.diff %>% ndiffs() #checando
# diferen√ßa sazonal
nsdiffs(dados.diff)
```



```{r}
par(mfrow=c(2,1))
acf(dados.diff, 60)

#autocorrela√ß√£o parcial (PACF)
pacf(dados.diff, 60)
```
Para escolha do modelo utilizou-se a fun√ß√£o auto.arima do software com par√¢metros d=1 e D=0, foram testados todas as poss√≠veis combina√ß√µes de zero a tr√™s dos par√¢metros p,q,P,Q o modelo que obteve menor AIC corrigido foi selecionado como o melhor modelo para ser ajustado, logo para o modelo 1 obteve-se um ARIMA(2,1,0)X(1,0,0)12.



```{r}
# depois da escolha deduzir o modelo
MODELO1 = auto.arima(x, d=1, D= 0, max.p = 3,max.q = 3, max.P = 3, max.Q = 3, trace=FALSE, allowdrift = FALSE,
stepwise=FALSE)
MODELO1
```
Ap√≥s a sele√ß√£o do modelo para serie de dados originais realizou-se uma transforma√ß√£o de boxcox nos dados e realizou-se novamente o mesmo processo realizado no passo anterior, por√©m para serie de dados hist√≥rica transformadam, na figura 3 tem a representa√ß√£o da serie original juntamente com a serie transformada.

```{r}
# aplicando a Transforma√ß√£o de BOXcox na serie
data_Bxcx <- BoxCox(x,lambda="auto")
plot(cbind(x,data_Bxcx))

```
Nota-se que n√£o houve uma diferen√ßa elevada no padr√£o de tend√™ncia e nem no padr√£o da sazonalidade isso indica que para as analises gr√°ficas n√£o obteve diferen√ßas significativa na dedu√ß√£o do modelo. Foram realizadas nesta serie teste de tend√™ncia, retornando o valor 1 sugerindo uma diferen√ßa simples para a serie. aplicada esta diferen√ßa a serie se tornou estacion√°ria. Ap√≥s foram plotados o ACF e PACF para dedu√ß√£o do modelo, por√©m n√£o foi poss√≠vel identificar todos os par√¢metros.

```{r}
#aplicando a diferen√ßa simples
data_Bxcx %>% ndiffs()
data_Bxcx.diff<- diff(data_Bxcx)
data_Bxcx.diff %>% ndiffs() #checando
nsdiffs(dados.diff)

```
```{r}
plot(cbind(data_Bxcx, data_Bxcx.diff))
```


```{r}
# depois da serie diferenciada analisar o acf e pacf
par(mfrow=c(2,1))
acf(data_Bxcx.diff, lag=4*12)
pacf(data_Bxcx.diff, lag=4*12)
```

Para identificar o modelo utilizou-se a abordagem simplista para estimar os par√¢metros p,q,P,Q, sendo d=1 e D=0. Foram testados os valores de destes par√¢metros de 0 a 3 e o modelo com melhor AICc foi escolhido foi um arima (2,1,1)x(1,0,0)12.

```{r}
# depois da escolha deduzir o modelo
MODELO2 = auto.arima(data_Bxcx, d=1, D= 0, max.p = 3,max.q = 3, max.P = 3, max.Q = 3, trace=FALSE, allowdrift = FALSE,
stepwise=FALSE)
MODELO2
```


O terceiro modelo foi proposto como alternativa para os modelos arimas, os modelos de alisamento exponencial ETS, para os dados sem a transforma√ß√£o de boxcox, o modelo obtido foi um ETS ajustado com tendencia multiplicativa, sazonalidade aditiva e o termo de erro multiplicativo, A figura demostra a serie decomposta no termo de level, serie original e a sazonalidade. 


```{r}
#modelo ETS
MODELO.ETS1 <- ets(x)

MODELO3<-MODELO.ETS1
MODELO3

#modelo ets(MAM)

```
```{r}
plot(MODELO.ETS1)
```


O quarto modelo proposto Foi o modelo ETS holt winter, com Erro multiplicativo, Tend√™ncia aditiva e sazonalidade Multiplicativa, a figura mostra a decomposi√ß√£o da serie em termos de level, sazonalidade e serie observada. O modelo foi gerado atrav√©s de uma fun√ß√£o autom√°tica no R que calcula os par√¢metros do modelO.
Ap√≥s o ajuste dos modelos foram avaliados os res√≠duos.
```{r}
#Modelo ETS com transforma√ß√£o de Boxcox

MODELO.ETS2 <- ets(x, lambda = "auto")
plot(MODELO.ETS2)
MODELO4<-MODELO.ETS2

#mODELO ETS(A,A,A)
```
```{r}
MODELO4
```


```{r}
#analise para o modelo 1
E1 <- MODELO1$residuals
E1 %>% plot(main = "Res√≠duos do modelo ARIMA(0,1,3)(2,0,0)[12] ")
```
Nas figuras acima demonstra o comportamento dos res√≠duos quanto a aleatoridade, o gr√°fico qqplot demonstra se os res√≠duos s√£o normais e o acf demonstra se ainda ha autorrela√ß√£o, ou seja, ele indica se os res√≠duos s√£o ou n√£o independentes, por√©m al√©m da anl√°lise gr√°fica faz se necessaria um avalia√ß√£o atrav√©s de testos estat√≠sticos sob hip√≥tese nula a rejei√ß√£o ou n√£o da normalidade, independencia e estacionaridade. Para os modelos selecionados foram avaliados estas pressuposi√ß√µes atrav√©s dos testes kpss (Testa estacionaridade), Box Ljung teste (Testa a idependencia dos res√≠duos) e shapiro wilks (Testa a normaliade dos res√≠duos)
```{r}
par(mfrow=c(2,1))
qqnorm(E1); qqline(E1); acf(E1, lag.max=12*5)
```

```{r}
E1=MODELO1$residuals
tseries::kpss.test(E1)
Box.test(E1, lag=15, type = "Ljung-Box")
shapiro.test(E1)
```

Para o modelo 1 (Arima sazonal), os res√≠duos passaram no teste a 5% de significancia para estacionaridade e independencia, para o teste de normalidade n√£o foi poss√≠vel rejeitar a hip√≥tese nula, ou seja, os res√≠duos n√£o s√£o normais, por√©m se o n√≠vel de sinificancia a ser considerado for de 1% todos os pressupostos seriam atendidos.

```{r}
E2=MODELO2$residuals
E2 <- MODELO2$residuals %>% plot(main = "Residuo Modelo2")
```



```{r}
MODELO2
E2=MODELO2$residuals
tseries::kpss.test(E2)
Box.test(E2, lag=15, type = "Ljung-Box")
shapiro.test(E2)

```
Para o modelo 2, aplicando os mesmo testes tem-se que os res√≠duos foram independentes, a serie √© estacion√°ria por√©m os res√≠duos n√£o s√£o normais a 5%.


```{r}
E3=MODELO3$residuals
tseries::kpss.test(E3)

## Teste de independ√™ncia

Box.test(E3, lag=15, type = "Ljung-Box")

## Teste de normalidade
shapiro.test(E3)
```

```{r}
E4=MODELO4$residuals
tseries::kpss.test(E4)

## Teste de independ√™ncia

Box.test(E4, lag=15, type = "Ljung-Box")

## Teste de normalidade
shapiro.test(E4)
```

# Janela deslizante

```{r, cache=TRUE}
n=length(x) 
corte=n-14

################
#

f_arima1 <- function(y, h){
  fit <- Arima(y, order=c(2, 1, 0), seasonal=c(1, 0, 0), include.mean=F, lambda=NULL)
  forecast(fit, h,bootstrap=T)
}
f_arima2 <- function(y, h){
  fit <- Arima(y, order=c(2, 1, 1), seasonal=c(1, 0, 0), include.mean=F)#, lambda='auto')
  forecast(fit, h,bootstrap=T)
}
f_ets1 <- function(y, h){
  fit <- ets(y)
  forecast(fit, h,bootstrap=T)
}
f_ets2 <- function(y, h){
  fit <- ets(y, lambda='0.6295 ')
  forecast(fit, h,bootstrap=T)
}
CV_arima1 <- x %>% tsCV(forecastfunction=f_arima1, h=5, initial=n-14)
CV_arima2 <- x %>% tsCV(forecastfunction=f_arima2, h=5, initial=n-14)
CV_ets1 <- x %>% tsCV(forecastfunction=f_ets1, h=5, initial=n-14)
CV_ets2 <- x %>% tsCV(forecastfunction=f_ets2, h=5, initial=n-14)
MAE_arima1 <- CV_arima1 %>% abs() %>% colMeans(na.rm=T)
MAE_arima2 <- CV_arima2 %>% abs() %>% colMeans(na.rm=T)
MAE_ets1 <- CV_ets1 %>% abs() %>% colMeans(na.rm=T)
MAE_ets2 <- CV_ets2 %>% abs() %>% colMeans(na.rm=T)
tab <- cbind(MAE_arima1, MAE_arima2, MAE_ets1, MAE_ets2)
tab %>%
  kable(
    col.names=c('ARIMA', 'ARIMA + Box-Cox', 'ETS', 'ETS + Box-Cox'),
    caption='MAE por horizonte de predi√ß√£o.',
    digits=0,
    format.args=list(decimal.mark=',', scientific=F),
    align='c'
  ) %>%
  kable_styling(
    position='center',
    bootstrap_options=c('striped', 'hover', 'condensed', 'responsive')
  )
tab_plot <- tab %>%
  as.data.frame() %>%
  mutate(Horizonte=1:5) %>%
  gather(key='Modelo', value='MAE', -Horizonte)
tab_plot %>%
  ggplot(aes(x=Horizonte, y=MAE)) +
  geom_line(aes(color=Modelo)) +
  scale_color_manual(
    values=c('black', 'red', '#0000AA', 'darkgreen'),
    breaks=c('MAE_arima1', 'MAE_arima2', 'MAE_ets1', 'MAE_ets2'),
    labels=c('ARIMA', 'ARIMA + Box-Cox', 'ETS', 'ETS + Box-Cox')
  ) +
  theme_bw()

```


Note que ETS mais boxcox n√£o √© indicado para esta an√°lise
```{r, cache=TRUE}
h=60
preds1 <- forecast(MODELO1, h=h, level=95)
preds2 <- forecast(MODELO2, h=h, level=95)
preds3 <- forecast(MODELO3, h=h, level=95)
preds4 <- forecast(MODELO4, h=h, level=95)
pontual <- t(cbind(xx, preds1$mean, preds2$mean, preds3$mean, preds4$mean))
colnames(pontual) <- 1:60
row.names(pontual) <- c('Observado', 'ARIMA', 'ARIMA + Box-Cox', 'ETS', 'ETS + Box-Cox')
pontual %>%
  kable(
    caption='Previs√µes pontuais por horizonte de predi√ß√£o.',
    digits=0,
    format.args=list(decimal.mark=',', scientific=F),
    align='c'
  ) %>%
  kable_styling(
    position='center',
    bootstrap_options=c('striped', 'hover', 'condensed', 'responsive')
  )

```






```{r, cache=TRUE}
## Ajuste e previs√£o do modelo e c√°lculo do erro absoluto m√©dio da previs√£o
# tables



intervalares <- t(cbind(xx, preds1$lower, preds1$upper, preds2$lower, preds2$upper,
                        preds3$lower, preds3$upper, preds4$lower, preds4$upper))
colnames(intervalares) <- 1:h
row.names(intervalares) <- c('Observado', 'ARIMA Inf', 'ARIMA Sup', 'ARIMA + Box-Cox Inf',
                             'ARIMA + Box-Cox Sup', 'ETS Inf', 'ETS Sup', 'ETS + Box-Cox Inf',
                             'ETS + Box-Cox Sup')
intervalares %>%
  kable(
    caption='Previs√µes intervalares de 95% de confian√ßa por horizonte de predi√ß√£o.',
    digits=0,
    format.args=list(decimal.mark=',', scientific=F),
    align='c'
  ) %>%
  kable_styling(
    position='center',
    bootstrap_options=c('striped', 'hover', 'condensed', 'responsive')
  )


```


```{r, cache=TRUE}

# plots
plot_preds <- function(mod, nome='') {
  vec <- c(nome, 'Observado')
  cores <- c('#0000AA', 'red')
  names(cores) <- vec
  preds <- forecast(mod, h=h, level=95)
  plot_obj <- x %>%
    autoplot() + xlab('Ano') + ylab('Valor Observado') + theme_bw() +
    autolayer(preds, series=nome) +
    autolayer(xx, series='Observado') +
    scale_colour_manual(
      values=cores,
      breaks=vec,
      name='')
  return(plot_obj)
}
plot_preds(MODELO1, 'ARIMA')








```
```{r, cache=TRUE}
plot_preds(MODELO2, 'ARIMA + Box-Cox')


```
Modelo √© ETS com transforma√ß√£o de box cox √© invi√°vel a utiliza√ß√£o.
```{r, cache=TRUE, warning=FALSE}
plot_preds(MODELO3, 'ETS')
```

```{r, cache=TRUE, warning=FALSE}
plot_preds(MODELO4, 'ETS + Box-Cox')
```



```{r, warning=FALSE, cache=TRUE}
# Benchmark comparison
preds <- list(
  'ARIMA' = forecast(MODELO1, h=h),
  'ARIMA + Box-Cox' = forecast(MODELO2, h=h),
  'ETS' = forecast(MODELO3, h=h),
  'ETS + Box-Cox' = forecast(MODELO4, h=h),
  'auto.arima' = forecast(auto.arima(x), h=h),
  'SES' = ses(x, h=h),
  'Holt' = holt(x, h=h),
  'sltf' = stlf(x, h=h),
  'BATS' = forecast(bats(x), h=h),
  'TBATS' = forecast(tbats(x), h=h),
  'Bagged ETS' = forecast(baggedETS(x), h=h)
)
mae <- unlist(lapply(preds, function(m) return(mean(abs(xx - m$mean)))))
final <- data.frame(MAE=mae)
final %>%
  kable(
    caption='MAE nos dados de teste.',
    digits=0,
    format.args=list(decimal.mark=',', scientific=F),
    align='c'
  ) %>%
  kable_styling(
    position='center',
    bootstrap_options=c('striped', 'hover', 'condensed', 'responsive')
  )
```

# Referencias Bibliogr√°ficas
BOX, G.E., JENKINS, G.M. and REINSEL, G. C. (1994). Time Series: Forecasting and 
Control (3rd edition). Prentice Hall.

HYNDMAN, R. J. et al. Previs√£o com suaviza√ß√£o exponencial: A abordagem do espa√ßo de estados. Berlim: Springer-Verlag, 2008

R Development Core Team (2009). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. ISBN 3-900051-07-0, URL http://www.R-project.org.






